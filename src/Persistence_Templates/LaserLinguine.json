[{"type":"worker","sender":{"instance_id":"persistence","resource_id":"persistence","modality":"persistence"},"receiver":{"instance_id":"ui","resource_id":"ui","modality":"ui"},"payload":{"LOAD_SESSION":true,"state":{"tree":{"65bb6811-68dc-4f77-acc8-b78b680212bf":{"type":"b","id":"65bb6811-68dc-4f77-acc8-b78b680212bf","inhabited":false,"root":false,"parentId":"c4a21273-ccd8-4574-9b24-a0f319d06868","payload":{"address":"https://mtrifonov-design.github.io/pinsandcurves-panels/#code"}},"c4a21273-ccd8-4574-9b24-a0f319d06868":{"type":"c","id":"c4a21273-ccd8-4574-9b24-a0f319d06868","children":{"leftId":"65bb6811-68dc-4f77-acc8-b78b680212bf","rightId":"3504c35b-3aec-4dbf-b93d-26f629e6515b"},"percentage":0.41398116013882,"direction":"row","root":true},"65df9343-a05e-4e66-ab0c-238ab9aa96f6":{"type":"b","id":"65df9343-a05e-4e66-ab0c-238ab9aa96f6","inhabited":false,"root":false,"parentId":"3504c35b-3aec-4dbf-b93d-26f629e6515b","payload":{"address":"https://mtrifonov-design.github.io/pinsandcurves-panels/#editing"}},"3504c35b-3aec-4dbf-b93d-26f629e6515b":{"type":"c","id":"3504c35b-3aec-4dbf-b93d-26f629e6515b","children":{"leftId":"218416d0-b274-4e63-81ad-f70c19783555","rightId":"65df9343-a05e-4e66-ab0c-238ab9aa96f6"},"percentage":0.5,"direction":"column","root":false,"parentId":"c4a21273-ccd8-4574-9b24-a0f319d06868"},"072350c7-eea8-4c4f-937d-e6aef86a3682":{"type":"b","id":"072350c7-eea8-4c4f-937d-e6aef86a3682","inhabited":false,"root":false,"parentId":"218416d0-b274-4e63-81ad-f70c19783555","payload":{"address":"https://mtrifonov-design.github.io/pinsandcurves-panels/#signals"}},"abbc8238-1b30-446b-bc47-16151cddc7ab":{"type":"b","id":"abbc8238-1b30-446b-bc47-16151cddc7ab","inhabited":false,"root":false,"parentId":"218416d0-b274-4e63-81ad-f70c19783555","payload":{"address":"https://mtrifonov-design.github.io/pinsandcurves-panels/#p5"}},"218416d0-b274-4e63-81ad-f70c19783555":{"type":"c","id":"218416d0-b274-4e63-81ad-f70c19783555","children":{"leftId":"072350c7-eea8-4c4f-937d-e6aef86a3682","rightId":"abbc8238-1b30-446b-bc47-16151cddc7ab"},"percentage":0.2707856598016781,"direction":"row","root":false,"parentId":"3504c35b-3aec-4dbf-b93d-26f629e6515b"}},"renderId":"zzfndbgp0il"}},"id":"e8h1jb0nhak"},{"type":"worker","sender":{"instance_id":"persistence","resource_id":"persistence","modality":"persistence"},"receiver":{"modality":"wasmjs","resource_id":"https://mtrifonov-design.github.io/pinsandcurves-background-services/ProjectState","instance_id":"BACKGROUND"},"payload":{"LOAD_SESSION":true,"state":{"worm":"{\"content\":{\"metaData\":{\"name\":\"Empty Project\",\"pinsAndCurvesVersion\":\"0.0.1\"},\"orgData\":{\"signalIds\":[\"s1\"],\"signalIdByPinId\":{\"89302457611\":\"s1\",\"59214957192\":\"s1\",\"82377767819\":\"s1\",\"g3zw5\":\"s1\"},\"pinIds\":[\"89302457611\",\"59214957192\",\"82377767819\",\"g3zw5\"],\"signalNames\":{\"s1\":\"rays\"},\"signalTypes\":{\"s1\":\"continuous\"},\"activeSignalIds\":[\"s1\"]},\"timelineData\":{\"numberOfFrames\":900,\"framesPerSecond\":30,\"playheadPosition\":135,\"focusRange\":[15,300],\"playing\":false},\"signalData\":{\"s1\":{\"id\":\"s1\",\"type\":\"continuous\",\"range\":[0,1],\"pinIds\":[\"89302457611\",\"g3zw5\",\"59214957192\",\"82377767819\"],\"pinTimes\":{\"89302457611\":23,\"59214957192\":214,\"82377767819\":241,\"g3zw5\":51},\"pinValues\":{\"89302457611\":0,\"59214957192\":1,\"82377767819\":0,\"g3zw5\":1},\"curves\":{\"89302457611\":\"return easyLinear()\",\"59214957192\":\"return easyEaseOut()\",\"82377767819\":\"return easyLinear();\",\"g3zw5\":\"return easyLinear();\"},\"defaultCurve\":\"return easyLinear();\",\"defaultValue\":0}},\"templateData\":{}},\"__internal\":{\"namedStates\":{\"commit\":\"statetDKJtjSevG\"},\"states\":{\"initial\":{\"forward\":[],\"backward\":[],\"nextState\":\"stateEeQucpxKgL\"},\"stateEeQucpxKgL\":{\"forward\":[{\"type\":\"updateSignalName\",\"signalId\":\"s1\",\"signalName\":\"Ball Y\"}],\"backward\":[{\"type\":\"updateSignalName\",\"signalId\":\"s1\",\"signalName\":\"Signal 1\"}],\"nextState\":\"statecrAKkuxHNW\",\"previousState\":\"initial\"},\"statecrAKkuxHNW\":{\"forward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":79}],\"backward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":78}],\"nextState\":\"statedrUJCaHXfw\",\"previousState\":\"stateEeQucpxKgL\"},\"statedrUJCaHXfw\":{\"forward\":[{\"type\":\"updatePins\",\"pins\":[{\"pinId\":\"89302457611\",\"pinTime\":15,\"pinValue\":0,\"functionString\":\"return easyLinear()\"},{\"pinId\":\"59214957192\",\"pinTime\":37,\"pinValue\":1,\"functionString\":\"return easyEaseOut()\"},{\"pinId\":\"82377767819\",\"pinTime\":60,\"pinValue\":0,\"functionString\":\"return easyEaseIn()\"}]}],\"backward\":[{\"type\":\"updatePins\",\"pins\":[{\"pinId\":\"89302457611\",\"pinTime\":20,\"pinValue\":0,\"functionString\":\"return easyLinear()\"},{\"pinId\":\"59214957192\",\"pinTime\":40,\"pinValue\":1,\"functionString\":\"return easyEaseOut()\"},{\"pinId\":\"82377767819\",\"pinTime\":60,\"pinValue\":0,\"functionString\":\"return easyEaseIn()\"}]}],\"nextState\":\"statejBtUiCAXuM\",\"previousState\":\"statecrAKkuxHNW\"},\"statejBtUiCAXuM\":{\"forward\":[{\"type\":\"updateFocusRange\",\"focusRange\":[15,100]}],\"backward\":[{\"type\":\"updateFocusRange\",\"focusRange\":[0,100]}],\"nextState\":\"stateXBECnXEKxk\",\"previousState\":\"statedrUJCaHXfw\"},\"stateXBECnXEKxk\":{\"forward\":[{\"type\":\"updateFocusRange\",\"focusRange\":[15,100]}],\"backward\":[{\"type\":\"updateFocusRange\",\"focusRange\":[15,100]}],\"nextState\":\"stategSdhUJpgAF\",\"previousState\":\"statejBtUiCAXuM\"},\"stategSdhUJpgAF\":{\"forward\":[{\"type\":\"updateFocusRange\",\"focusRange\":[15,60]}],\"backward\":[{\"type\":\"updateFocusRange\",\"focusRange\":[15,100]}],\"nextState\":\"stateLYXyihWvZG\",\"previousState\":\"stateXBECnXEKxk\"},\"stateLYXyihWvZG\":{\"forward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":15}],\"backward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":59}],\"previousState\":\"stategSdhUJpgAF\",\"nextState\":\"statehXusfkJSTy\"},\"statehXusfkJSTy\":{\"forward\":[{\"type\":\"updatePins\",\"pins\":[{\"pinId\":\"89302457611\",\"pinTime\":23,\"pinValue\":0,\"functionString\":\"return easyLinear()\"},{\"pinId\":\"59214957192\",\"pinTime\":130,\"pinValue\":1,\"functionString\":\"return easyEaseOut()\"},{\"pinId\":\"82377767819\",\"pinTime\":241,\"pinValue\":0,\"functionString\":\"return easyEaseIn()\"}]}],\"backward\":[{\"type\":\"updatePins\",\"pins\":[{\"pinId\":\"89302457611\",\"pinTime\":15,\"pinValue\":0,\"functionString\":\"return easyLinear()\"},{\"pinId\":\"59214957192\",\"pinTime\":37,\"pinValue\":1,\"functionString\":\"return easyEaseOut()\"},{\"pinId\":\"82377767819\",\"pinTime\":60,\"pinValue\":0,\"functionString\":\"return easyEaseIn()\"}]}],\"nextState\":\"statevxJCJCGvMs\",\"previousState\":\"stateLYXyihWvZG\"},\"statevxJCJCGvMs\":{\"forward\":[{\"type\":\"updatePins\",\"pins\":[{\"pinId\":\"59214957192\",\"pinTime\":214,\"pinValue\":1,\"functionString\":\"return easyEaseOut()\"}]}],\"backward\":[{\"type\":\"updatePins\",\"pins\":[{\"pinId\":\"59214957192\",\"pinTime\":130,\"pinValue\":1,\"functionString\":\"return easyEaseOut()\"}]}],\"nextState\":\"stateQhcWSCcBui\",\"previousState\":\"statehXusfkJSTy\"},\"stateQhcWSCcBui\":{\"forward\":[{\"type\":\"addPin\",\"signalId\":\"s1\",\"pinId\":\"g3zw5\",\"pinTime\":51,\"pinValue\":1,\"functionString\":\"return easyLinear();\",\"bezierControlPoints\":[-5,0,5,0]}],\"backward\":[{\"type\":\"deletePin\",\"pinId\":\"g3zw5\"}],\"nextState\":\"statedHGbmdZLLz\",\"previousState\":\"statevxJCJCGvMs\"},\"statedHGbmdZLLz\":{\"forward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":51}],\"backward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":15}],\"nextState\":\"stateulbeEhVXtk\",\"previousState\":\"stateQhcWSCcBui\"},\"stateulbeEhVXtk\":{\"forward\":[{\"type\":\"updateCurve\",\"pinId\":\"82377767819\",\"functionString\":\"return easyLinear();\"}],\"backward\":[{\"type\":\"updateCurve\",\"pinId\":\"82377767819\",\"functionString\":\"return easyEaseIn()\"}],\"nextState\":\"stateNShcLYnydu\",\"previousState\":\"statedHGbmdZLLz\"},\"stateNShcLYnydu\":{\"forward\":[{\"type\":\"updateFocusRange\",\"focusRange\":[15,300]}],\"backward\":[{\"type\":\"updateFocusRange\",\"focusRange\":[15,60]}],\"nextState\":\"statebPYhDnrQMi\",\"previousState\":\"stateulbeEhVXtk\"},\"statebPYhDnrQMi\":{\"forward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":41}],\"backward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":40}],\"nextState\":\"stateOFQNbKfPKT\",\"previousState\":\"stateNShcLYnydu\"},\"stateOFQNbKfPKT\":{\"forward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":129}],\"backward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":128}],\"previousState\":\"statebPYhDnrQMi\",\"nextState\":\"stateNGKuWtxKXI\"},\"stateNGKuWtxKXI\":{\"forward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":54}],\"backward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":129}],\"nextState\":\"stateyEwTpXhxGN\",\"previousState\":\"stateOFQNbKfPKT\"},\"stateyEwTpXhxGN\":{\"forward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":138}],\"backward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":54}],\"previousState\":\"stateNGKuWtxKXI\",\"nextState\":\"stateKMCdcVztVW\"},\"stateKMCdcVztVW\":{\"forward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":64}],\"backward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":138}],\"previousState\":\"stateyEwTpXhxGN\",\"nextState\":\"statetOEMiBheuZ\"},\"statetOEMiBheuZ\":{\"forward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":51}],\"backward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":64}],\"nextState\":\"stateMDMFErRaxy\",\"previousState\":\"stateKMCdcVztVW\"},\"stateMDMFErRaxy\":{\"forward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":96}],\"backward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":95}],\"nextState\":\"stateRHSLSeyuxG\",\"previousState\":\"statetOEMiBheuZ\"},\"stateRHSLSeyuxG\":{\"forward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":254}],\"backward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":253}],\"previousState\":\"stateMDMFErRaxy\",\"nextState\":\"statekvPpDcQwVH\"},\"statekvPpDcQwVH\":{\"forward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":291}],\"backward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":290}],\"nextState\":\"statevQWxCYubgy\",\"previousState\":\"stateRHSLSeyuxG\"},\"statevQWxCYubgy\":{\"forward\":[{\"type\":\"updateSignalName\",\"signalId\":\"s1\",\"signalName\":\"rays\"}],\"backward\":[{\"type\":\"updateSignalName\",\"signalId\":\"s1\",\"signalName\":\"Ball Y\"}],\"nextState\":\"statelKBkJPTFVx\",\"previousState\":\"statekvPpDcQwVH\"},\"statelKBkJPTFVx\":{\"forward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":231}],\"backward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":230}],\"nextState\":\"statetDKJtjSevG\",\"previousState\":\"statevQWxCYubgy\"},\"statetDKJtjSevG\":{\"forward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":135}],\"backward\":[{\"type\":\"updatePlayheadPosition\",\"playheadPosition\":134}],\"previousState\":\"statelKBkJPTFVx\"}},\"cursor\":\"statetDKJtjSevG\",\"maxSize\":10000}}"}},"id":"4sfxuqw2x66"},{"type":"worker","sender":{"instance_id":"persistence","resource_id":"persistence","modality":"persistence"},"receiver":{"modality":"wasmjs","resource_id":"https://mtrifonov-design.github.io/pinsandcurves-background-services/AssetServer","instance_id":"ASSET_SERVER"},"payload":{"LOAD_SESSION":true,"state":[{"asset_id":"P5JSSKETCH","asset_name":"P5JS Sketch","asset_type":"application/javascript","dataUrl":"(function () {\n/*\n\n▗▖    ▗▄▖  ▗▄▄▖▗▄▄▄▖▗▄▄▖     ▗▖   ▗▄▄▄▖▗▖  ▗▖ ▗▄▄▖▗▖ ▗▖▗▄▄▄▖▗▖  ▗▖▗▄▄▄▖\n▐▌   ▐▌ ▐▌▐▌   ▐▌   ▐▌ ▐▌    ▐▌     █  ▐▛▚▖▐▌▐▌   ▐▌ ▐▌  █  ▐▛▚▖▐▌▐▌   \n▐▌   ▐▛▀▜▌ ▝▀▚▖▐▛▀▀▘▐▛▀▚▖    ▐▌     █  ▐▌ ▝▜▌▐▌▝▜▌▐▌ ▐▌  █  ▐▌ ▝▜▌▐▛▀▀▘\n▐▙▄▄▖▐▌ ▐▌▗▄▄▞▘▐▙▄▄▖▐▌ ▐▌    ▐▙▄▄▖▗▄█▄▖▐▌  ▐▌▝▚▄▞▘▝▚▄▞▘▗▄█▄▖▐▌  ▐▌▐▙▄▄▖\n\n    Laser Linguine\n    This experiment is part of the Pins and Curves project.\n    Read more: https://pinsandcurves.app\n\n    This is an early beta. It is not stable.\n    \n    How to render:\n    - Press render in the preview panel.\n    - Wait until a zip file with an image sequence is downloaded.\n    - This can take longer than a minute.\n\n    Adjust the values in the section below to customize.\n\n*/\n//  ----------------------------------------------------------\n\n\n\nconst colors            = [\n//      each row describes a gradient\n//      every ray gets one of the gradients assigned\n//      the correct format is:\n//      [ r1,  g1,  b1,  r2,  g2,  b2  ],\n        [ 219, 204, 242, 43,  188, 184 ],\n        [ 32,  42,  132, 43,  188, 184 ],\n        [ 255, 255, 255, 255, 0,   0   ],\n        [ 255, 255, 255, 0,   255, 0   ],\n        [ 255, 255, 255, 0,   0,   255 ]\n]\nconst background_color = [50,50,0];\n\nconst center_point              = [0.5,0.5];\n\nconst stripe_rays               = 195;           // number of rays\nconst stripe_rays_lifecycle     = 70;            // how long does each ray live (frames)\nconst stripe_thickness          = 0.01;\nconst stripe_variation          = 0.3;\n\nconst burst_rays                = 45;\nconst burst_rays_lifecycle      = 40;\nconst burst_thickness           = 0.03;\nconst burst_variation           = 0.3;\n\nconst preview                   = true;         // reduces number of rays for faster preview\n\n/*\n\n    Anything below this point is code not meant to be adjusted.\n\n*/\nconst darkening_factor = 1.5;\nconst burst_offset              = 20;\nconst BURST_MAX         = preview ? Math.floor(burst_rays / 2)  : burst_rays;\nconst STRIPE_MAX        = preview ? Math.floor(stripe_rays / 2)  : stripe_rays;\nconst TEX_HEIGHT        = 3;\nconst BURST_LIFE        = burst_rays_lifecycle;\nconst STRIPE_LIFE       = stripe_rays_lifecycle;\nconst SIGNAL_MAX_FRAME  = 900;\nconst powVal = darkening_factor;\n\nconst TWO_PI = Math.PI * 2;\nlet   globalProgress = 1;\n\n\nconst rand  = s     => (((Math.sin(s) * 43758.5453123) % 1) + 1) / 2;\nconst randN = (k,n) => rand(k + n*1.61803398875);\n\n/*------------------------------------------------- SLOT PHASES -----*/\nconst burstPhase  = new Uint16Array(BURST_MAX);\nconst stripePhase = new Uint16Array(STRIPE_MAX);\nfor (let i = 0; i < BURST_MAX;  ++i) burstPhase [i] = Math.floor(rand(i+1) *  BURST_LIFE);\nfor (let i = 0; i < STRIPE_MAX; ++i) stripePhase[i] = Math.floor(rand(i+2) *  STRIPE_LIFE);\n\n/*-------------------------------------------------- WEBGL SET‑UP ---*/\nconst canvas          = document.createElement('canvas');\ncanvas.width          = 1920;\ncanvas.height         = 1080;\ncanvas.style.height   = '100%';\ncanvas.style.width    = 'auto';\ndocument.body.appendChild(canvas);\n\nconst gl = canvas.getContext('webgl2', { preserveDrawingBuffer: true });\nif (!gl) { console.error('WebGL2 not supported'); return; }\n\n/* additive blending so per‑ray strips accumulate ------------------*/\ngl.enable(gl.BLEND);\ngl.blendEquation(gl.FUNC_ADD);\ngl.blendFunc(gl.ONE, gl.ONE);\n\n/*-------------------------------------------------- SHADERS --------*/\n/* vertex shader builds a thin quad around each ray ----------------*/\nconst vsSource = `#version 300 es\nprecision mediump float;\n#define TEX_HEIGHT ${TEX_HEIGHT}\n\nin  vec2 a_corner;                 // (x=0|1 along ray, y=-1|1 across)\nflat out int   v_rayIndex;         // instance id to fragment shader\nout vec2       v_texCoord;         // screen‑space (0‥1) for fragment\n\nuniform vec2      u_center;        // pivot of burst (0‥1 coords)\nuniform vec2      u_resolution;    // px size, for aspect\nuniform sampler2D u_paramsTex;     // ray parameters\n\nvoid main () {\n    int  idx  = gl_InstanceID;\n    v_rayIndex = idx;\n\n    /* fetch first row: angle / variance / start / end -------------*/\n    vec4 p0 = texelFetch(u_paramsTex, ivec2(idx,0), 0);\n    vec4 p1 = texelFetch(u_paramsTex, ivec2(idx,1), 0);\n\n    float angle     = p0.x;\n    float startDist = p0.z;\n    float endDist   = p0.w;\n    float variance  = p0.y;\n    float softness  = p1.x;\n\n    /* pick width ~ 3σ + soft edge -------------------------------*/\n    float width = variance * 3.0 + softness * 1.5;\n\n    float asp = u_resolution.x / u_resolution.y;\n    vec2  dir = vec2(cos(angle) / asp,  sin(angle));          // radial dir\n    vec2  nrm = normalize(vec2(-dir.y, dir.x));               // outward normal\n\n    float along = mix(startDist, endDist, a_corner.x);        // 0→1 along ray\n    vec2  pos   = u_center + dir * along + nrm * width * a_corner.y;\n\n    v_texCoord  = pos;                                        // 0‥1 screen\n    gl_Position = vec4(pos * 2.0 - 1.0, 0.0, 1.0);            // clip‑space\n}`;\n\n/* fragment shader shades **one** ray (no loop!) -------------------*/\nconst fsSource = `#version 300 es\nprecision mediump float;\n#define TEX_HEIGHT ${TEX_HEIGHT}\n\nin  vec2       v_texCoord;\nflat in  int   v_rayIndex;\nout vec4       fragColor;\n\nuniform vec2      u_resolution;\nuniform vec2      u_center;\nuniform sampler2D u_paramsTex;\n\nconst float PI = 3.141592653589793;\n\n/* helpers ---------------------------------------------------------*/\nfloat wrapAngle (float a){ return mod(a + PI, 2.0*PI) - PI; }\nfloat angularGaussian (float t,float a,float v){\n    float d = wrapAngle(t - a);\n    return exp(-0.5 * d*d / (v*v));\n}\nfloat radialMask (float r,float s,float e,float soft){\n    float up   = smoothstep(s,      s + soft, r);\n    float down = smoothstep(e-soft, e,        r);\n    return up * (1.0 - down);\n}\nfloat radialGradient (float r,float R){ return clamp(r / R, 0.0, 1.0); }\n\nvoid main (){\n    /* fetch parameters for this ray ------------------------------*/\n    int   idx = v_rayIndex;\n    ivec2 c0  = ivec2(idx, 0), c1 = ivec2(idx, 1), c2 = ivec2(idx, 2);\n\n    vec4 p0 = texelFetch(u_paramsTex, c0, 0);\n    vec4 p1 = texelFetch(u_paramsTex, c1, 0);\n    vec4 p2 = texelFetch(u_paramsTex, c2, 0);\n\n    float angle      = p0.x, variance = p0.y;\n    float startDist  = p0.z, endDist  = p0.w;\n    float softness   = p1.x, colorRad = p1.y;\n    vec3  cA         = vec3(p1.z, p1.w, p2.x);\n    vec3  cB         = vec3(p2.y, p2.z, p2.w);\n\n    /* polar coords (match original shader) -----------------------*/\n    vec2  uv  = v_texCoord - u_center;\n    float asp = u_resolution.x / u_resolution.y;\n    uv.x     *= asp;\n\n    float r     = length(uv);\n    float theta = atan(uv.y, uv.x);\n\n    float wA = angularGaussian(theta, angle,   variance);\n    float wR = radialMask     (r,     startDist, endDist, softness);\n    float wG = radialGradient (r,     colorRad);\n\n    vec3 col = mix(cA, cB, wG) * (wA * wR);\n\n    fragColor = vec4(col, 1.0);                   // additive alpha\n}`;\n\n/*------------------------------------------------------------------*/\n/*  Program + quad                                                  */\n/*------------------------------------------------------------------*/\nfunction compile (t, src){\n  const s = gl.createShader(t);\n  gl.shaderSource(s, src);\n  gl.compileShader(s);\n  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))\n      console.error(gl.getShaderInfoLog(s));\n  return s;\n}\nconst vs   = compile(gl.VERTEX_SHADER,   vsSource);\nconst fs   = compile(gl.FRAGMENT_SHADER, fsSource);\nconst prog = gl.createProgram();\ngl.attachShader(prog, vs);\ngl.attachShader(prog, fs);\ngl.linkProgram(prog);\nif (!gl.getProgramParameter(prog, gl.LINK_STATUS))\n    console.error(gl.getProgramInfoLog(prog));\ngl.useProgram(prog);\n\n/* local‑space quad: 2 tris, (x:0→1 along, y:‑1/1 across) ----------*/\nconst quad = new Float32Array([\n  0, -1,   0,  1,   1,  1,\n  0, -1,   1,  1,   1, -1\n]);\nconst vbo = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, vbo);\ngl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);\n\nconst locCorner = gl.getAttribLocation(prog, 'a_corner');\ngl.enableVertexAttribArray(locCorner);\ngl.vertexAttribPointer(locCorner, 2, gl.FLOAT, false, 0, 0);\n\n/*------------------------------------------------------------------*/\n/*  GPU parameter texture                                            */\n/*------------------------------------------------------------------*/\nconst TOTAL_MAX = BURST_MAX + STRIPE_MAX;\nconst rayData   = new Float32Array(TOTAL_MAX * TEX_HEIGHT * 4);\n\nconst tex = gl.createTexture();\ngl.bindTexture(gl.TEXTURE_2D, tex);\ngl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, TOTAL_MAX, TEX_HEIGHT,\n              0, gl.RGBA, gl.FLOAT, rayData);\n\n/*------------------------------------------------------------------*/\n/*  Uniform locations                                               */\n/*------------------------------------------------------------------*/\nconst uRes  = gl.getUniformLocation(prog, 'u_resolution');\nconst uCen  = gl.getUniformLocation(prog, 'u_center');\nconst uTex  = gl.getUniformLocation(prog, 'u_paramsTex');\ngl.uniform1i(uTex, 0);   // texture unit 0\n\n/*------------ deterministic per‑cycle property generators ----------*/\nfunction burstParams (i, c){\n  const k = 100 * i + c;\n  return {\n    maxLen:   1.8  * (0.9 + randN(k,1)*0.2),\n    variance: burst_thickness*(1 + randN(k,1)*burst_variation - burst_variation / 2),\n    softness: 0.2  * (0.9 + randN(k,3)*0.2),\n    colorRad: 1.0  * (0.9 + randN(k,4)*0.2),\n    angle: randN(k,5)*TWO_PI\n  };\n}\nfunction stripeParams (i, c){\n  const k = 100 * i + c;\n  return {\n    variance: stripe_thickness*(1 + randN(k,1)*stripe_variation - stripe_variation / 2),\n    softness:0.1     *(0.9 + randN(k,2)*0.2),\n    angle: randN(k,3)*TWO_PI\n  };\n}\n\n/*------------------------------ PACK TO FLOAT32ARRAY ---------------*/\nfunction packRay (j, p){\n  const b  = j * 4,\n        r1 = TOTAL_MAX * 4 + b,\n        r2 = 2 * TOTAL_MAX * 4 + b;\n\n  rayData[b   ] = p.angle;        rayData[b+1] = p.variance;\n  rayData[b+2] = p.start;        rayData[b+3] = p.end;\n\n  rayData[r1  ] = p.softness;     rayData[r1+1] = p.colorRadius;\n  rayData[r1+2] = p.color1[0]*p.fade; rayData[r1+3] = p.color1[1]*p.fade;\n\n  rayData[r2  ] = p.color1[2]*p.fade; rayData[r2+1] = p.color2[0]*p.fade;\n  rayData[r2+2] = p.color2[1]*p.fade; rayData[r2+3] = p.color2[2]*p.fade;\n}\n\n/*----------------------------------------------------- MAIN DRAW ---*/\nfunction draw (){\n  /* regenerate active rays each frame -----------------------------*/\n  let frame      = playhead();\n  globalProgress = signal_(\"rays\");\n  let count      = 0;\n\n  /*========== BURST SLOTS =========================================*/\n  frame = Math.max(frame - burst_offset, 0);\n  for (let i = 0; i < BURST_MAX; ++i){\n    const phase = burstPhase[i];\n    if (frame < phase) continue;\n    const rel   = frame - phase;\n    const cyc   = Math.floor(rel / BURST_LIFE);\n    const fIn   = rel % BURST_LIFE;\n    const birthFrame = frame - fIn;\n\n    const sigFrame = Math.min(birthFrame, SIGNAL_MAX_FRAME);\n    if (i >= Math.round(signal_(\"rays\", sigFrame) * BURST_MAX)) continue;\n\n    const t    = fIn / BURST_LIFE;\n    const p    = burstParams(i, cyc);\n    const dist = easeInExpo(t) * 2.5;\n    const len  = 0.01 + (p.maxLen - 0.01)*t;\n\n\n    const col = colors[Math.floor(rand(i)*colors.length)]\n      const col1 = col.slice(0,3);\n      const col2 = col.slice(3);\n\n    packRay(count++, {\n      angle: p.angle, variance: p.variance,\n      start: dist,    end: dist + len,\n      softness: p.softness, colorRadius: p.colorRad,\n      fade: 1,\n      color1: col1.map(num => Math.pow(num / 255,powVal)),\n      color2: col2.map(num => Math.pow(num / 255,powVal)),\n    });\n  }\n\n  /*========== STRIPE SLOTS ========================================*/\n  frame = playhead();\n  for (let i = 0; i < STRIPE_MAX; ++i){\n    const phase = stripePhase[i];\n    const rel   = frame - phase;\n    const cyc   = Math.floor(rel / STRIPE_LIFE);\n    const fIn   = rel % STRIPE_LIFE;\n    const birthFrame = frame - fIn;\n\n    const sigFrame = Math.min(birthFrame, SIGNAL_MAX_FRAME);\n    if (i >= Math.floor(signal_(\"rays\", sigFrame) * STRIPE_MAX)) continue;\n\n    const t   = fIn / STRIPE_LIFE;\n    const p   = stripeParams(i, cyc);\n    const end = Math.min(easeInExpo(t*1.75),1) * 2.5;\n\n\n      const c = colors.length;\n      const k = 100 * i + c;\n      //console.log(randN(k,colors.length));\n      const col = colors[Math.floor(rand(i)*colors.length)]\n      const col1 = col.slice(0,3);\n      const col2 = col.slice(3);\n\n\n    packRay(count++, {\n      angle: p.angle, variance: p.variance,\n      start: 0,       end,\n      softness: p.softness, colorRadius: 1,\n          fade: 1-easeInSine(t),\n      color1: col1.map(num => Math.pow(num / 255,powVal)),\n      color2: col2.map(num => Math.pow(num / 255,powVal)),\n    });\n  }\n\n  /*---------------- PUSH PARAM DATA & DRAW ------------------------*/\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(gl.TEXTURE_2D, tex);\n  gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, TOTAL_MAX, TEX_HEIGHT,\n                   gl.RGBA, gl.FLOAT, rayData);\n\n  gl.viewport(0, 0, canvas.width, canvas.height);\n  gl.clearColor(...background_color.map(num => Math.pow(num / 255,powVal)), 1);\n  gl.clear(gl.COLOR_BUFFER_BIT);\n\n  gl.uniform2f(uRes, canvas.width, canvas.height);\n  gl.uniform2f(uCen, ...center_point);\n\n  if (count > 0) gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, count);\n\n  requestAnimationFrame(draw);\n}\nrequestAnimationFrame(draw);\n\n/* guard for frame 0 → signal --------------------------------------*/\nfunction signal_ (name, frame){\n  if (frame === 0) return 0;\n  return signal(name, frame);\n}\n\n/*------------------------------------------------------ PLAYHEAD ---*/\nfunction playhead () {\n  try { return client.c.getProject().timelineData.playheadPosition; }\n  catch (e) { return 0; }\n}\n\nfunction easeInExpo(x) {\nreturn x === 0 ? 0 : Math.pow(2, 10 * x - 10);\n}\n\n    function easeInSine(x) {\n  return 1 - Math.cos((x * Math.PI) / 2);\n}\n\n})();\n"}]},"id":"llykxvg9t3"}]